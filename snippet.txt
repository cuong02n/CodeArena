{
	"for in": {
		"prefix": "forin",
		"body": [
			"for(int i = 0; i < n; i++){",
			"\t$0",
			"}"
		]
	},
	"for loop": {
		"prefix": "fori",
		"body": [
			"for(int ${1:i} = $2; ${1:i} < $3; ${1:i}++){",
			"\t$0",
			"}"
		]
	},
	"code forces (test case )": {
		"prefix": "code_t",
		"body": [
			"/*",
			"    author : cuong2905say",
			"    created : 27-07-2023  20:39:16  UTC: +7",
			"*/",
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"using ll = long long;",
			"using ull = unsigned long long;",
			"",
			"template <class T1, class T2>",
			"ostream& operator<<(ostream& os, pair<T1, T2> A) {",
			"    os << \" { \" << A.first << \", \" << A.second << \" }\";",
			"    return os;",
			"}",
			"template <class T1, class T2, class T3>",
			"ostream& operator<<(ostream& os, tuple<T1, T2, T3> A) {",
			"    os << \" { \" << get<0>(A) << \", \" << get<1>(A) << \", \" << get<2>(A) << \" }\";",
			"    return os;",
			"}",
			"template <class T1, class T2, class T3, class T4>",
			"ostream& operator<<(ostream& os, tuple<T1, T2, T3, T4> A) {",
			"    os << \" { \" << get<0>(A) << \", \" << get<1>(A) << \", \" << get<2>(A) << \", \" << get<3>(A) << \" }\";",
			"    return os;",
			"}",
			"template <class T>",
			"ostream& operator<<(ostream& os, vector<T> A) {",
			"    os << \" vector : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T>",
			"ostream& operator<<(ostream& os, set<T> A) {",
			"    os << \" set : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T>",
			"ostream& operator<<(ostream& os, multiset<T> A) {",
			"    os << \" multiset : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T>",
			"ostream& operator<<(ostream& os, deque<T> A) {",
			"    os << \" deque : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T1, class T2>",
			"ostream& operator<<(ostream& os, map<T1, T2> A) {",
			"    os << \" map : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T1, class T2>",
			"ostream& operator<<(ostream& os, multimap<T1, T2> A) {",
			"    os << \" multimap : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T1, class T2>",
			"ostream& operator<<(ostream& os, unordered_map<T1, T2> A) {",
			"    os << \" unordered_map : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T>",
			"ostream& operator<<(ostream& os, priority_queue<T> A) {",
			"    os << \" priority_queue : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"",
			"int MOD = 1e9 + 7;",
			"int verbose = -1;",
			"void solve(bool v = false) {",
			"    $0",
			"",
			"    if (v) {",
			"    }",
			"}",
			"",
			"void reset() {",
			"}",
			"",
			"int main() {",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(0);",
			"    cout.tie(0);",
			"    chrono::steady_clock::time_point start = chrono::steady_clock::now();",
			"",
			"#ifndef ONLINE_JUDGE",
			"    freopen(\"input.txt\", \"r\", stdin);",
			"    freopen(\"output.txt\", \"w\", stdout);",
			"#endif",
			"",
			"    int t = 1;",
			"    cin >> t;",
			"    for (int i = 0; i < t; i++) {",
			"#ifndef ONLINE_JUDGE",
			"        cout << \"case \" << i + 1 << \": \";",
			"#endif",
			"        if (verbose == i + 1) {",
			"            solve(true);",
			"        } else {",
			"            solve();",
			"        }",
			"        reset();",
			"    }",
			"    chrono::steady_clock::time_point end = chrono::steady_clock::now();",
			"#ifndef ONLINE_JUDGE",
			"    chrono::duration<double> time_span = chrono::duration_cast<std::chrono::duration<double>>(end - start);",
			"    cout << \"time use: \" << time_span.count() << endl;",
			"#endif",
			"",
			"    return 0;",
			"}",
			"",
			""
		]
	},
	"code forces ": {
		"prefix": "code_forces",
		"body": [
			"/*",
			"\tauthor : cuong2905say",
			"\tcreated : ${CURRENT_DATE}-$CURRENT_MONTH-$CURRENT_YEAR  $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND  UTC: +7",
			"*/",
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"using ll = long long;",
			"using ull = unsigned long long;",
			"",
			"template <class T1, class T2>",
			"ostream& operator<<(ostream& os, pair<T1, T2> A) {",
			"    os << \" { \" << A.first << \", \" << A.second << \" }\";",
			"    return os;",
			"}",
			"template <class T1, class T2, class T3>",
			"ostream& operator<<(ostream& os, tuple<T1, T2, T3> A) {",
			"    os << \" { \" << get<0>(A) << \", \" << get<1>(A) << \", \" << get<2>(A) << \" }\";",
			"    return os;",
			"}",
			"template <class T1, class T2, class T3, class T4>",
			"ostream& operator<<(ostream& os, tuple<T1, T2, T3, T4> A) {",
			"    os << \" { \" << get<0>(A) << \", \" << get<1>(A) << \", \" << get<2>(A) << \", \" << get<3>(A) << \" }\";",
			"    return os;",
			"}",
			"template <class T>",
			"ostream& operator<<(ostream& os, vector<T> A) {",
			"    os << \" vector : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T>",
			"ostream& operator<<(ostream& os, set<T> A) {",
			"    os << \" set : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T>",
			"ostream& operator<<(ostream& os, multiset<T> A) {",
			"    os << \" multiset : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T>",
			"ostream& operator<<(ostream& os, deque<T> A) {",
			"    os << \" deque : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T1, class T2>",
			"ostream& operator<<(ostream& os, map<T1, T2> A) {",
			"    os << \" map : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T1, class T2>",
			"ostream& operator<<(ostream& os, multimap<T1, T2> A) {",
			"    os << \" multimap : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T1, class T2>",
			"ostream& operator<<(ostream& os, unordered_map<T1, T2> A) {",
			"    os << \" unordered_map : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"template <class T>",
			"ostream& operator<<(ostream& os, priority_queue<T> A) {",
			"    os << \" priority_queue : \";",
			"    for (auto x : A) {",
			"        os << x << \" \";",
			"    }",
			"    return os;",
			"}",
			"",
			"int MOD = 1e9 + 7;",
			"int n = 0;",
			"void solve() {",
			"    $0",
			"}",
			"",
			"int main() {",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(0);",
			"    cout.tie(0);",
			"",
			"#ifndef ONLINE_JUDGE",
			"    freopen(\"input.txt\", \"r\", stdin);",
			"    freopen(\"output.txt\", \"w\", stdout);",
			"#endif",
			"",
			"    solve();",
			"    return 0;",
			"}",
			"",
			""
		]
	},
	"cout array,vector...": {
		"prefix": "cout_c()",
		"body": [
			"for (auto x : ${1:}A) {",
			"        cout << x << \" \";",
			"    }",
			"cout << endl;",
			""
		]
	},
	"cout flag YES/NO": {
		"prefix": "cout_f()",
		"body": [
			"cout << (flag ? \"YES\" : \"NO\") << endl;",
			"$0"
		]
	},
	"() hàm tính số 2^k mà không vượt quá x ()": {
		"prefix": "() bit : max(2^k) ()",
		"body": [
			"template <typename T>",
			"T find_MEXP(T x) {",
			"    if (x == 0) {",
			"        return 0;",
			"    }",
			"    T shifted_bit = 0;",
			"    while (x != 1) {",
			"        x >>= 1;",
			"        shifted_bit++;",
			"    }",
			"    return x << shifted_bit;",
			"}",
			""
		]
	},
	"[] hàm tính số 2^k mà không vượt quá x [lambda]": {
		"prefix": "[lambda] bit : max(2^k) []",
		"body": [
			"[] template <typename T> ",
			"    (T x) {",
			"    if (x == 0) {",
			"        return 0;",
			"    }",
			"    T shifted_bit = 0;",
			"    while (x != 1) {",
			"        x >>= 1;",
			"        shifted_bit++;",
			"    }",
			"    return x << shifted_bit;",
			"    }($0);",
			""
		]
	},
	"pause": {
		"prefix": "system pause",
		"body": [
			"system(\"pause\");",
			""
		]
	},
	"async, 0 tie": {
		"prefix": "ios_",
		"body": [
			"ios_base::sync_with_stdio(false);",
			"cin.tie(0);cout.tie(0);",
			""
		]
	},
	"while loop": {
		"prefix": "while",
		"body": [
			"while($1){",
			"\t$0",
			"}"
		]
	},
	"for": {
		"prefix": "for",
		"body": [
			"for (int ${1:i} = ${2:0}; ${1:i} < $3; ${1:i}++){",
			"\t$0",
			"}"
		]
	},
	"do": {
		"prefix": "do",
		"body": [
			"do{",
			"\t$1",
			"} while($2);"
		]
	},
	"while": {
		"prefix": "while",
		"body": [
			"while ($1){",
			"\t$0",
			"}"
		]
	},
	"foreach": {
		"prefix": "foreach",
		"body": [
			"for(auto ${var} : ${collection_to_loop}){",
			"\t$1",
			"}"
		]
	},
	"if": {
		"prefix": "if",
		"body": [
			"if ($1){",
			"\t$0",
			"}"
		]
	},
	"else": {
		"prefix": "else",
		"body": [
			"else{",
			"\t$0",
			"}"
		]
	},
	"else if": {
		"prefix": "else if",
		"body": [
			"else if ($1){",
			"\t$0",
			"}"
		]
	},
	"enum": {
		"prefix": "enum",
		"body": [
			"enum ${MyEnum}{",
			"\t$0",
			"};"
		]
	},
	"enum class": {
		"prefix": "enum class",
		"body": [
			"enum class ${MyClass} { };"
		]
	},
	"class": {
		"prefix": "class",
		"body": [
			"class ${MyClass}{",
			"public:",
			"\t${MyClass}();",
			"\t${MyClass}(${MyClass} &&) = default;",
			"\t${MyClass}(const ${MyClass} &) = default;",
			"\t${MyClass} &operator=(${MyClass} &&) = default;",
			"\t${MyClass} &operator=(const ${MyClass} &) = default;",
			"\t~${MyClass}();",
			"",
			"private:",
			"\t$0",
			"};",
			"",
			"${MyClass}::${MyClass}(){",
			"}",
			"",
			"${MyClass}::~${MyClass}(){",
			"}"
		]
	},
	"interface": {
		"prefix": "interface",
		"body": [
			"__interface I${Interface}{",
			"\t$0",
			"};"
		]
	},
	"namespace": {
		"prefix": "namespace",
		"body": [
			"namespace ${MyNamespace}{",
			"\t$0",
			"}"
		]
	},
	"#ifdef": {
		"prefix": "#ifdef",
		"body": [
			"#ifdef ${DEBUG}",
			"$1",
			"#endif // ${DEBUG}"
		]
	},
	"#ifndef": {
		"prefix": "#ifndef",
		"body": [
			"#ifndef ${1:1}",
			"$2",
			"#endif // !$1"
		]
	},
	"#if": {
		"prefix": "#if",
		"body": [
			"#ifdef ${1:0}",
			"$2",
			"#endif // $1"
		]
	},
	"struct": {
		"prefix": "struct",
		"body": [
			"struct ${MyStruct}{",
			"\t$0",
			"};"
		]
	},
	"switch": {
		"prefix": "switch",
		"body": [
			"switch ($1){",
			"\t$0",
			"\tdefault:",
			"\t\tbreak;$1",
			"}"
		]
	},
	"try": {
		"prefix": "try",
		"body": [
			"try{",
			"\t$1",
			"}",
			"catch (const std::exception&){",
			"\t$0",
			"}"
		]
	},
	"union": {
		"prefix": "union",
		"body": [
			"union ${MyUnion}{",
			"\t$0",
			"};"
		]
	},
	"cout": {
		"prefix": "cout",
		"body": [
			"cout << $0 << endl;"
		]
	},
	"#include": {
		"prefix": "#inc",
		"body": [
			"#include \"$1\""
		]
	},
	"#inc<": {
		"prefix": "#inc<",
		"body": [
			"#include <$1>"
		]
	},
	"#def": {
		"prefix": "#def",
		"body": [
			"#define \"$1\" \"$2\" "
		]
	},
	"main()": {
		"prefix": "main()",
		"body": [
			"int main() {",
			"\t$0",
			"\treturn 0;",
			"}"
		]
	},
	"() hàm kiểm tra có phải số nguyên tố ()": {
		"prefix": "() is_prime ()",
		"body": [
			"template <typename T>",
			"int is_prime(T n){",
			"\tif(n <= 1){",
			"\t\treturn 0;",
			"\t}",
			"\tif(n <= 3){",
			"\t\treturn 1;",
			"\t}",
			"\tfor(T i = 2; i * i <= n; i++){",
			"\t\tif(n % i == 0){",
			"\t\t\treturn 0;",
			"\t\t}",
			"\t}",
			"\treturn 1;",
			"}",
			""
		]
	},
	"() hàm lấy phần nguyên của hàm loga(b) ()": {
		"prefix": "() integer_part_of_log ()",
		"body": [
			"template <typename T>",
			"int integer_part_of_log(T a, T b) {",
			"    // log_a(b);",
			"    // a>=1;",
			"    if (a == 1) {",
			"        std: :cout << \"invalid : (base 1)\" << std: :endl;",
			"        return INT_MAX;",
			"    }",
			"    T _a = a;",
			"    for (int i = 1; i < 1000; i++) {",
			"        if (a == b) {",
			"            return i;",
			"        }",
			"        if (a > b) {",
			"            return i - 1;",
			"        }",
			"        a *= _a;",
			"    }",
			"    return -1;",
			"}",
			""
		]
	},
	"[] hàm lấy phần nguyên của hàm loga(b) [lambda]": {
		"prefix": "[lambda] integer_part_of_log []",
		"body": [
			"[] template <typename T>(T a, T b) {",
			"    // log_a(b);",
			"    // a>=1;",
			"    if (a == 1) {",
			"        std: :cout << \"invalid : (base 1)\" << std: :endl;",
			"        return INT_MAX;",
			"    }",
			"    T _a = a;",
			"    for (int i = 1; i < 1000; i++) {",
			"        if (a == b) {",
			"            return i;",
			"        }",
			"        if (a > b) {",
			"            return i - 1;",
			"        }",
			"        a *= _a;",
			"    }",
			"    return -1;",
			"}($0);",
			""
		]
	},
	"() hàm tính điểm nhỏ nhất 2 đoạn giao ()": {
		"prefix": "() min_intersection()",
		"body": [
			"int min_intersection(int l1,int r1,int l2,int r2){",
			"//return min_intersection if its intersect,else return INT_MAX;",
			"\tif(r1==r2){",
			"\t\treturn max(l1,l2);",
			"\t}else if(r1>r2){",
			"\t\tif(l1>r2){",
			"\t\t\treturn INT_MAX;",
			"\t\t}else {",
			"\t\t\treturn max(l1,l2);",
			"\t\t}",
			"\t}else {",
			"\t\t//r1<r2",
			"\t\tif(l2>r1){",
			"\t\t\treturn INT_MAX;",
			"\t\t}else{",
			"\t\t\treturn max(l2,l1);",
			"\t\t}",
			"\t}",
			"\treturn INT_MAX;",
			"}",
			""
		]
	},
	"{} DISJOINT SET UNION {}": {
		"prefix": "{} DSU {}",
		"body": [
			"template <class T>",
			"class DSU {",
			"   public:",
			"    T *arr_Par;",
			"    T *arr_size;",
			"    DSU(T n) {",
			"        arr_Par = (T *)malloc(sizeof(T) * n);",
			"        arr_size = (T *)malloc(sizeof(T) * n);",
			"        make_set(n);",
			"    }",
			"    ~DSU() {",
			"        delete arr_Par;",
			"        delete arr_size;",
			"    }",
			"    void make_set(T n) {",
			"        for (int i = 0; i < n; i++) {",
			"            arr_Par[i] = i;",
			"            arr_size[i] = 1;",
			"        }",
			"    }",
			"    void merge(T t1, T t2) {",
			"        t1 = find(t1);",
			"        t2 = find(t2);",
			"        if (t1 != t2) {",
			"            // 2 tap hop khac nhau ;",
			"            if (arr_size[t1] < arr_size[t2]) {",
			"                // ghep t1 vao t2",
			"                arr_Par[t1] = t2;",
			"            } else {",
			"                arr_Par[t2] = t1;",
			"            }",
			"",
			"            arr_size[t2] += arr_size[t1];",
			"            arr_size[t1] = arr_size[t2];",
			"        }",
			"    }",
			"    T find(T t) {",
			"        if (t == arr_Par[t]) {",
			"            return t;",
			"        }",
			"        return arr_Par[t] = find(arr_Par[t]);",
			"    }",
			"    T get_size(T t) {",
			"        return arr_size[find(t)];",
			"    }",
			"",
			"    DSU(){};",
			"    DSU(DSU &&) = default;",
			"    DSU(const DSU &) = default;",
			"    DSU &operator=(DSU &&) = default;",
			"    DSU &operator=(const DSU &) = default;",
			"    ~DSU(){};",
			"",
			"   private:",
			"};",
			""
		]
	},
	"() đếm số ước ()": {
		"prefix": "() count_divisor ()",
		"body": [
			"",
			"template <typename T>",
			"int count_divisor(T n) {",
			"    // O (n^1/2) , I need improve to O (n^1/3);",
			"    int res = 0;",
			"    if (sqrt(n) == (long long)sqrt(n)) {",
			"        res++;",
			"    }",
			"    for (T i = 1; i * i < n; i++) {",
			"        if (!(n % i)) {",
			"            res += 2;",
			"        }",
			"    }",
			"    return res;",
			"}($0)",
			"",
		],
		"description": "đếm số ước dương từ 1->n O(n^1/2)"
	},
	"[] đếm số ước [lambda]": {
		"prefix": "[lambda] count_divisor []",
		"body": [
			"[]<typename T>(T n) {",
			"    // O (n^1/2) , I need improve to O (n^1/3);",
			"    int res = 0;",
			"    if (sqrt(n) == (long long)sqrt(n)) {",
			"        res++;",
			"    }",
			"    for (T i = 1; i * i < n; i++) {",
			"        if (!(n % i)) {",
			"            res += 2;",
			"        }",
			"    }",
			"    return res;",
			"}($1);",
			"$0"
		]
	},
	"{} Cây nhị phân {}": {
		"prefix": "{} BST_TREE {}",
		"body": [
			"template <typename T>",
			"class BST_Tree {",
			"   public:",
			"    struct node {",
			"        T value;",
			"        node *left;",
			"        node *right;",
			"    };",
			"    node *root = NULL;",
			"    int size = 0;",
			"    node *new_node(T value) {",
			"        node *q = (node *)malloc(sizeof(node));",
			"        q->left = NULL;",
			"        q->right = NULL;",
			"        q->value = value;",
			"        return q;",
			"    }",
			"",
			"   private:",
			"    void __pre_order(node *n) {",
			"        if (n != NULL) {",
			"            cout << n->value << \" \";",
			"            __pre_order(n->left);",
			"            __pre_order(n->right);",
			"        }",
			"    }",
			"",
			"    void __in_order(node *n) {",
			"        if (n != NULL) {",
			"            __in_order(n->left);",
			"            cout << n->value << \" \";",
			"            __in_order(n->right);",
			"        }",
			"    }",
			"",
			"    void __post_order(node *n) {",
			"        if (n != NULL) {",
			"            __post_order(n->left);",
			"            __post_order(n->right);",
			"            cout << n->value << \" \";",
			"        }",
			"    }",
			"",
			"    node *__insert(T x, node *n) {",
			"        if (n == NULL) {",
			"            n = new_node(x);",
			"        } else if (n->value >= x) {",
			"            n->left = __insert(x, n->left);",
			"        } else {",
			"            n->right = __insert(x, n->right);",
			"        }",
			"        return n;",
			"    }",
			"",
			"    node *__find(T x, node *n) {",
			"        if (n == NULL) {",
			"            return NULL;",
			"        }",
			"        if (n->value == x) {",
			"            return n;",
			"        }",
			"        if (n->value < x) {",
			"            return __find(x, n->right);",
			"        }",
			"        return __find(x, n->left);",
			"    }",
			"",
			"    node *__delete(T x, node *n) {",
			"        return n;",
			"    }",
			"",
			"   public:",
			"    node *find(T x) {",
			"        node *n = root;",
			"        return __find(x, n);",
			"    }",
			"",
			"    void insert(T x) {",
			"        if (root == NULL) {",
			"            root = new_node(x);",
			"        } else {",
			"            node *n = root;",
			"            root = __insert(x, n);",
			"        }",
			"        size++;",
			"    }",
			"",
			"    void insert(const vector<T> &a) {",
			"        for (T i : a) {",
			"            insert(i);",
			"        }",
			"    }",
			"",
			"    void *end() {",
			"        return NULL;",
			"    }",
			"",
			"    void pre_order() {",
			"        __pre_order(root);",
			"        cout << endl;",
			"    }",
			"",
			"    void in_order() {",
			"        // cout << \"In order \" << endl;",
			"        __in_order(root);",
			"        cout << endl;",
			"    }",
			"",
			"    void post_order() {",
			"        __post_order(root);",
			"        cout << endl;",
			"    }",
			"",
			"    BST_Tree(){};",
			"    BST_Tree(T x) {",
			"        root = new_node(x);",
			"    }",
			"    BST_Tree(BST_Tree &&) = default;",
			"    BST_Tree(const BST_Tree &) = default;",
			"    BST_Tree &operator=(BST_Tree &&) = default;",
			"    BST_Tree &operator=(const BST_Tree &) = default;",
			"    ~BST_Tree(){};",
			"};",
			""
		]
	},
	"{} Đồ thị vô hướng có trọng số{}": {
		"prefix": "{} un_dir_graph {}",
		"body": [
			"template <typename T1, typename T2>  // T1 is node(vertex), T2 is valuetype of weight",
			"class un_dir_graph {",
			"   public:",
			"    map<T1, map<T1, T2> > A;  // sorted with dictionary order",
			"    map<T1, bool> visited;",
			"    vector<T1> res;",
			"    map<T1, T1> parent;",
			"",
			"   private:",
			"    int edge = 0;",
			"    int vertex = 0;",
			"",
			"   public:",
			"    void clear() {",
			"        A.clear();",
			"        visited.clear();",
			"        res.clear();",
			"        parent.clear();",
			"    }",
			"    void _DFS(T1 x) {",
			"        // start from x",
			"        stack<T1> s;",
			"        while (!(s.empty())) {",
			"            s.pop();",
			"        }",
			"        s.push(x);",
			"        while (!(s.empty())) {",
			"            T1 i = s.top();",
			"            s.pop();",
			"",
			"            if (visited.find(i) == visited.end()) {",
			"                continue;",
			"            }",
			"            visited.erase(i);",
			"            res.push_back(i);",
			"            for (typename map<T1, T2>::reverse_iterator q = A[i].rbegin(); q != A[i].rend(); q++) {",
			"                T1 p = q->first;",
			"                if (visited.find(p) != visited.end()) {",
			"                    s.push(p);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    vector<T1> _DFS_to_k(T1 x, int k) {",
			"        // start from x",
			"        visited.clear();",
			"        for (auto i : A) {",
			"            visited.insert({i.first, false});",
			"        }",
			"        res.clear();",
			"        stack<T1> s;",
			"        while (!(s.empty())) {",
			"            s.pop();",
			"        }",
			"        s.push(x);",
			"        while (!(s.empty())) {",
			"            if (res.size() == k) {",
			"                return res;",
			"            }",
			"            T1 i = s.top();",
			"            s.pop();",
			"",
			"            if (visited[i]) {",
			"                continue;",
			"            }",
			"            visited[i] = true;",
			"            res.push_back(i);",
			"",
			"            for (typename map<T1, T2>::reverse_iterator q = A[i].rbegin(); q != A[i].rend(); q++) {",
			"                T1 p = q->first;",
			"                if (!visited[p]) {",
			"                    s.push(p);",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    vector<T1> BFS(T1 x) {  // start from x",
			"        int c = 0;",
			"        visited.clear();",
			"        for (auto i : A) {",
			"            visited.insert({i.first, false});",
			"        }",
			"        res.clear();",
			"        queue<T1> s;",
			"        while (!(s.empty())) {",
			"            s.pop();",
			"        }",
			"        s.push(x);",
			"        c++;",
			"        visited[x] = true;",
			"        while (!(s.empty())) {",
			"            T1 i = s.front();",
			"            s.pop();",
			"            res.push_back(i);",
			"            c++;",
			"            for (auto q : A[i]) {",
			"                T1 p = q.first;",
			"                if (!visited[p]) {",
			"                    s.push(p);",
			"                    visited[p] = true;",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"",
			"    vector<T1> DFS(T1 x) {",
			"        // start from x",
			"        visited.clear();",
			"        for (auto i : A) {",
			"            visited.insert({i.first, false});",
			"        }",
			"        res.clear();",
			"        stack<T1> s;",
			"        while (!(s.empty())) {",
			"            s.pop();",
			"        }",
			"        s.push(x);",
			"        while (!(s.empty())) {",
			"            T1 i = s.top();",
			"            s.pop();",
			"",
			"            if (visited[i]) {",
			"                continue;",
			"            }",
			"            visited[i] = true;",
			"            res.push_back(i);",
			"            for (typename map<T1, T2>::reverse_iterator q = A[i].rbegin(); q != A[i].rend(); q++) {",
			"                T1 p = q->first;",
			"                if (!visited[p]) {",
			"                    s.push(p);",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"",
			"    vector<T1> find_path(T1 y, T1 x) {",
			"        if (A.find(x) == A.end() || A.find(y) == A.end()) {",
			"            return res;",
			"        }",
			"        res.clear();",
			"",
			"        if (x == y) {",
			"            res.push_back(x);",
			"            return res;",
			"        }",
			"        // using BFS.",
			"        //  find path from x to y( shortest )",
			"        visited.clear();",
			"        for (auto i : A) {",
			"            visited.insert({i.first, false});",
			"        }",
			"        parent.clear();",
			"        queue<T1> s;",
			"        while (!(s.empty())) {",
			"            s.pop();",
			"        }",
			"        int flag = 1;",
			"        s.push(x);",
			"        parent.insert({x, x});",
			"        visited[x] = true;",
			"        while (!(s.empty())) {",
			"            T1 i = s.front();",
			"            s.pop();",
			"            for (auto q : A[i]) {",
			"                T1 p = q.first;",
			"                if (!visited[p]) {",
			"                    s.push(p);",
			"                    parent.insert({p, i});",
			"                    if (p == y) {",
			"                        flag = 1;",
			"                        break;",
			"                    }",
			"                    visited[p] = true;",
			"                }",
			"            }",
			"        }",
			"        if (flag) {",
			"            res.push_back(y);",
			"            auto before = y;",
			"            auto i = parent[y];",
			"            while (i != before) {",
			"                res.push_back(i);",
			"                before = i;",
			"                i = parent[i];",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"",
			"    void add(T1 x, T1 y, T2 w = 0) {  // O(1);",
			"        // insert with w is weight",
			"        if (A.find(x) == A.end() && A.find(y) == A.end()) {",
			"            map<T1, T2> i1;",
			"            i1.insert(pair<T1, T2>(y, w));",
			"            map<T1, T2> i2;",
			"            i2.insert(pair<T1, T2>(x, w));",
			"            A.insert(pair<T1, map<T1, T2> >(x, i1));",
			"            A.insert(pair<T1, map<T1, T2> >(y, i2));",
			"        } else if (A.find(x) == A.end()) {",
			"            map<T1, T2> i;",
			"            i.insert(pair<T1, T2>(y, w));",
			"            A.insert(pair<T1, map<T1, T2> >(x, i));",
			"            A[y].insert(pair<T1, T2>(x, w));",
			"        } else if (A.find(y) == A.end()) {",
			"            map<T1, T2> i;",
			"            i.insert(pair<T1, T2>(x, w));",
			"            A.insert(pair<T1, map<T1, T2> >(y, i));",
			"            A[x].insert(pair<T1, T2>(y, w));",
			"        } else {",
			"            A[x].insert(pair<T1, T2>(y, w));",
			"            A[y].insert(pair<T1, T2>(x, w));",
			"        }",
			"    }",
			"    void add_vertex_only(T1 x) {",
			"        map<T1, T2> i;",
			"        A.insert({x, i});",
			"    }",
			"",
			"    int get_edge() {",
			"        edge = 0;",
			"        for (auto i : A) {",
			"            edge += (i.second).size();",
			"        }",
			"        edge >>= 1;",
			"        return edge;",
			"    }",
			"",
			"    int number_Connected_Component() {",
			"        int NBCC = 0;",
			"        visited.clear();",
			"        for (auto i : A) {",
			"            visited.insert({i.first, false});",
			"        }",
			"        while (!(visited.empty())) {",
			"            NBCC++;",
			"            _DFS(visited.begin()->first);",
			"        }",
			"        return NBCC;",
			"    }",
			"    int have_cycle() {",
			"        if (get_edge() > get_vertex() - number_Connected_Component()) {",
			"            return 1;",
			"        }",
			"        return 0;",
			"    }",
			"",
			"    int get_vertex() {",
			"        vertex = A.size();",
			"        return vertex;",
			"    }",
			"",
			"    T1 get_first() {",
			"        return (A.begin())->first;",
			"    }",
			"",
			"    void erase(T1 x) {",
			"        if (A.find(x) != A.end()) {",
			"            // founded",
			"            for (auto i : A[x]) {",
			"                A[i.first].erase(x);",
			"            }",
			"            A.erase(x);",
			"        }",
			"    }",
			"    int min_path(T1 x, T1 y) {",
			"        auto _s = find_path(x, y);",
			"        return _s.size() - 1;",
			"    }",
			"",
			"    void display_MAP() {",
			"        for (auto i : A) {",
			"            cout << i.first << \" \\\" \";",
			"            for (auto j : i.second) {",
			"                cout << \" \" << j.first << \" , \" << j.second << \" \";",
			"            }",
			"            cout << \" \\\" \" << endl;",
			"        }",
			"    }",
			"",
			"    un_dir_graph(){};",
			"    un_dir_graph(un_dir_graph &&) = default;",
			"    un_dir_graph(const un_dir_graph &) = default;",
			"    un_dir_graph &operator=(un_dir_graph &&) = default;",
			"    un_dir_graph &operator=(const un_dir_graph &) = default;",
			"    ~un_dir_graph(){};",
			"",
			"   private:",
			"};",
			""
		]
	},
	"{} Cây {}": {
		"prefix": "{} Tree {}",
		"body": [
			"template <typename T>",
			"class Tree {",
			"   public:",
			"    struct node {",
			"        T value;",
			"        node *right;",
			"        node *left_child;",
			"    };",
			"    vector<T> res;",
			"",
			"   private:",
			"    node *_find(T x, node *r) {",
			"        if (r == NULL) {",
			"            return r;",
			"        }",
			"        if (r->value == x) {",
			"            return r;",
			"        }",
			"        node *it = r->left_child;",
			"        while (it != NULL) {",
			"            node *f = find(x, it);",
			"            if (f != NULL) {",
			"                return f;",
			"            }",
			"            it = it->right;",
			"        }",
			"        return NULL;",
			"    }",
			"",
			"   public:",
			"    node *root = NULL;",
			"    node *new_node(T x) {",
			"        node *q = (node *)malloc(sizeof(node));",
			"        q->value = x;",
			"        q->left_child = NULL;",
			"        q->right = NULL;",
			"    }",
			"",
			"    node *find(T x) {",
			"        return _find(x, root);",
			"    }",
			"    void add(T x, T y) {",
			"        // assert y is exist in this tree",
			"        // add x to y",
			"        node *p = find(y);",
			"        node *q = new_node(x);",
			"        if (p->left_child == NULL) {",
			"            p->left_child = q;",
			"            return;",
			"        }",
			"        p = p->left_child;",
			"        while (p->right != NULL) {",
			"            p = p->right;",
			"        }",
			"        p->right = q;",
			"    }",
			"",
			"   public:",
			"    Tree(){};",
			"    Tree(T x) {",
			"        root = new_root(x);",
			"    }",
			"    Tree(Tree &&) = default;",
			"    Tree(const Tree &) = default;",
			"    Tree &operator=(Tree &&) = default;",
			"    Tree &operator=(const Tree &) = default;",
			"    ~Tree(){};",
			"",
			"   private:",
			"};",
			""
		]
	},
	"() BigINT ()": {
		"prefix": "() BigINT ()",
		"body": [
			"string add(string a, string b);",
			"string sub(string a, string b);",
			"string mul(string a, string b);",
			"",
			"string sub(string a, string b) {",
			"    auto f = [](string __a) {",
			"        int _n = 0;",
			"        int _l = __a.length();",
			"        for (int __i = 0; __i < _l; __i++) {",
			"            if (__a[__i] <= '9' && __a[__i] >= '0') {",
			"                break;",
			"            }",
			"            _n++;",
			"        }",
			"        int n_dl = _n / 2 * 2;",
			"        __a = __a.substr(n_dl, _l - n_dl);",
			"        return __a;",
			"    };",
			"    auto g = [](string __a) {",
			"        int __n = 0;",
			"        int _l = __a.length();",
			"        for (int i = 0; i < __a.length(); i++) {",
			"            if (__a[i] == '0') {",
			"                __n++;",
			"            } else {",
			"                break;",
			"            }",
			"        }",
			"        return __a.substr(__n, _l - __n);",
			"    };",
			"    a = f(a);",
			"    b = f(b);",
			"    int _a_n = a.length();",
			"    int _b_n = b.length();",
			"    if (!_a_n) {",
			"        string _R = \"-\";",
			"        _R.append(b);",
			"        b = f(b);",
			"    }",
			"    if (!_b_n) {",
			"        return a;",
			"    }",
			"    if (a[0] == '-' && b[0] == '-') {",
			"        a = a.substr(1, _a_n - 1);",
			"        b = b.substr(1, _b_n - 1);",
			"        return sub(b, a);",
			"    } else if (b[0] == '-') {",
			"        b = b.substr(1, _b_n - 1);",
			"        return add(a, b);",
			"    } else if (a[0] == '-') {",
			"        string _R = \"-\";",
			"        a = a.substr(1, _a_n - 1);",
			"        return _R.append(add(a, b));",
			"    }",
			"    if (_a_n < _b_n) {",
			"        string _R = \"-\";",
			"        return _R.append(sub(b, a));",
			"    }",
			"    if (_a_n == _b_n) {",
			"        for (int i = 0; i < _a_n; i++) {",
			"            if (a[i] < b[i]) {",
			"                string _R = \"-\";",
			"                return _R.append(sub(b, a));",
			"            } else if (a[i] > b[i]) {",
			"                break;",
			"            }",
			"        }",
			"    }",
			"    string dont_copy_code = \"\";",
			"    int d = _a_n - _b_n;",
			"    int c = 0;",
			"    for (int i = _b_n - 1; i >= 0; i--) {",
			"        int r = a[i + d] - c - b[i];",
			"        if (r < 0) {",
			"            c = 1;",
			"            r += 10;",
			"        } else {",
			"            c = 0;",
			"        }",
			"        dont_copy_code.append(1, (char)(r + '0'));",
			"    }",
			"    for (int i = d - 1; i >= 0; i--) {",
			"        int r = a[i] - '0' - c;",
			"        if (r < 0) {",
			"            c = 1;",
			"            r += 10;",
			"        } else {",
			"            c = 0;",
			"        }",
			"        dont_copy_code.append(1, (char)(r + '0'));",
			"    }",
			"    reverse(dont_copy_code.begin(), dont_copy_code.end());",
			"    dont_copy_code = g(dont_copy_code);",
			"    if (dont_copy_code.length()) {",
			"        return dont_copy_code;",
			"    }",
			"    return \"0\";",
			"}",
			"string add(string a, string b) {",
			"    string dont_copy_code = \"\";",
			"    auto _f = [](string __a) {",
			"        int _n = 0;",
			"        int _l = __a.length();",
			"        for (int __i = 0; __i < _l; __i++) {",
			"            if (__a[__i] <= '9' && __a[__i] >= '0') {",
			"                break;",
			"            }",
			"            _n++;",
			"        }",
			"        int n_dl = _n / 2 * 2;",
			"        __a = __a.substr(n_dl, _l - n_dl);",
			"        return __a;",
			"    };",
			"    auto g = [](string __a) {",
			"        int __n = 0;",
			"        int _l = __a.length();",
			"        for (int i = 0; i < __a.length(); i++) {",
			"            if (__a[i] == '0') {",
			"                __n++;",
			"            } else {",
			"                break;",
			"            }",
			"        }",
			"        return __a.substr(__n, _l - __n);",
			"    };",
			"    a = _f(a);",
			"    b = _f(b);",
			"    int _a_n = a.length();",
			"    int _b_n = b.length();",
			"    if (_a_n == 0) {",
			"        return b;",
			"    }",
			"    if (_b_n == 0) {",
			"        return a;",
			"    }",
			"    if (a[0] == '-' && b[0] == '-') {",
			"        string _R = \"-\";",
			"        a = a.substr(1, _a_n - 1);",
			"        b = b.substr(1, _b_n - 1);",
			"        _R.append(add(a, b));",
			"        return _R;",
			"    } else if (b[0] == '-') {",
			"        b = b.substr(1, _b_n - 1);",
			"        return sub(a, b);",
			"    } else if (a[0] == '-') {",
			"        a = a.substr(1, _a_n - 1);",
			"        return sub(b, a);",
			"    }",
			"    if (_a_n < _b_n) {",
			"        return add(b, a);",
			"    }",
			"    int d = _a_n - _b_n;",
			"    int c = 0;",
			"    for (int i = _b_n - 1; i >= 0; i--) {",
			"        int r = a[i + d] - '0' + b[i] - '0' + c;",
			"        if (r > 9) {",
			"            c = 1;",
			"            r -= 10;",
			"        } else {",
			"            c = 0;",
			"        }",
			"        dont_copy_code.append(1, (char)(r + '0'));",
			"    }",
			"    for (int i = d - 1; i >= 0; i--) {",
			"        int r = a[i] - '0' + c;",
			"        if (r > 9) {",
			"            c = 1;",
			"            r -= 10;",
			"        } else {",
			"            c = 0;",
			"        }",
			"        dont_copy_code.append(1, (char)(r + '0'));",
			"    }",
			"",
			"    if (c) {",
			"        dont_copy_code.append(1, '1');",
			"    }",
			"    reverse(dont_copy_code.begin(), dont_copy_code.end());",
			"    dont_copy_code = g(dont_copy_code);",
			"    if (dont_copy_code.length()) {",
			"        return dont_copy_code;",
			"    }",
			"    return \"0\";",
			"}",
			"string _mul(string a, int b) {",
			"    if (b == 1) {",
			"        return a;",
			"    }",
			"    if (b == 0) {",
			"        return \"0\";",
			"    }",
			"    int _n = b / 2;",
			"    string r = add(a, a);",
			"    if (b & 1) {",
			"        return add(_mul(r, _n), a);",
			"    } else {",
			"        return _mul(r, _n);",
			"    }",
			"};",
			"string mul(string a, string b) {",
			"    auto _f = [](string __a) {",
			"        int _n = 0;",
			"        int _l = __a.length();",
			"        for (int __i = 0; __i < _l; __i++) {",
			"            if (__a[__i] <= '9' && __a[__i] >= '0') {",
			"                break;",
			"            }",
			"            _n++;",
			"        }",
			"        int n_dl = _n / 2 * 2;",
			"        __a = __a.substr(n_dl, _l - n_dl);",
			"        return __a;",
			"    };",
			"    auto g = [](string __a) {",
			"        int __n = 0;",
			"        int _l = __a.length();",
			"        for (int i = 0; i < __a.length(); i++) {",
			"            if (__a[i] == '0') {",
			"                __n++;",
			"            } else {",
			"                break;",
			"            }",
			"        }",
			"        return __a.substr(__n, _l - __n);",
			"    };",
			"    a = _f(a);",
			"    b = _f(b);",
			"    int _a_n = a.length();",
			"    int _b_n = b.length();",
			"    if (!_a_n || a == \"0\") {",
			"        return \"0\";",
			"    }",
			"",
			"    if (!_b_n || b == \"0\") {",
			"        return \"0\";",
			"    }",
			"    if (a[0] == '-' && b[0] == '-') {",
			"        a = a.substr(1, _a_n - 1);",
			"        b = b.substr(1, _b_n - 1);",
			"        return mul(a, b);",
			"    } else if (b[0] == '-') {",
			"        string _R = \"-\";",
			"        b = b.substr(1, _b_n - 1);",
			"        return _R.append(mul(a, b));",
			"    } else if (a[0] == '-') {",
			"        string _R = \"-\";",
			"        a = a.substr(1, _a_n - 1);",
			"        return _R.append(mul(a, b));",
			"    }",
			"    string _R = \"0\";",
			"    string _m[10];  // 1->9",
			"    _m[0] = \"0\";",
			"    for (int i = 1; i < 10; i++) {",
			"        _m[i] = _mul(a, i);",
			"    }",
			"    string _t = \"\";",
			"    for (int i = _b_n - 1; i >= 0; i--) {",
			"        // value for add number 0 after =b.length()-1 -i;",
			"        int v = b[i] - '0';",
			"        _t = _m[v];",
			"        _t.append(_b_n - 1 - i, '0');",
			"        _R = add(_R, _t);",
			"        _t = \"\";",
			"    }",
			"    return _R;",
			"}",
			""
		]
	},
	"{} Segment Tree {}": {
		"prefix": " Segment Tree",
		"body": [
			"int __n__;",
			"template <class T>",
			"class Segment_Tree {",
			"   private:",
			"    function<T(T, T)> f = [](T a, T b) {",
			"        return a + b;",
			"    };",
			"",
			"   public:",
			"    T *A = nullptr;",
			"    T *st = nullptr;",
			"",
			"    T get(int l, int r, int u = 1, int v = __n__, int id = 1) {",
			"        int mid = u + v >> 1;",
			"        if (v < l || r < u) {",
			"            return -1;",
			"        }",
			"",
			"        if (l <= u && v <= r) {",
			"            return st[id];",
			"        }",
			"        T m1 = get(l, r, u, mid, id * 2);",
			"        T m2 = get(l, r, mid + 1, v, id * 2 + 1);",
			"        return f(m1, m2);",
			"    }",
			"",
			"    void build(int i, int l, int r) {",
			"        if (l == r) {",
			"            st[i] = A[l];",
			"            return;",
			"        }",
			"        int mid = l + r >> 1;",
			"        build(2 * i, l, mid);",
			"        build(2 * i + 1, mid + 1, r);",
			"        st[i] = f(st[2 * i], st[2 * i + 1]);",
			"    }",
			"",
			"    void input() {",
			"        for (int i = 1; i <= __n__; i++) {",
			"            cin >> A[i];",
			"        }",
			"    }",
			"    Segment_Tree() = default;",
			"    Segment_Tree(int _n, function<T(T, T)> _f) {",
			"        f = _f;",
			"        __n__ = _n;",
			"        A = (T *)malloc(sizeof(T) * (__n__ + 1));",
			"        st = (T *)malloc(sizeof(T) * 4 * (__n__ + 1));",
			"        input();",
			"        build(1, 1, __n__);",
			"    }",
			"",
			"    Segment_Tree(Segment_Tree &&) = default;",
			"    Segment_Tree(const Segment_Tree &) = default;",
			"    Segment_Tree &operator=(Segment_Tree &&) = default;",
			"    Segment_Tree &operator=(const Segment_Tree &) = default;",
			"    ~Segment_Tree() {",
			"        delete A;",
			"        delete st;",
			"    }",
			"};",
			""
		]
	},
	"kadane - find max subset sequence sum": {
		"prefix": "kadane",
		"body": [
			"template <class T>",
			"T kadane(T A[], int size) {",
			"    T max_ending_here = 0;",
			"    T MAX = 0;",
			"    for (int i = 0; i < size; i++) {",
			"        max_ending_here += A[i];",
			"        if (max_ending_here < 0) {",
			"            max_ending_here = 0;",
			"        } else if (max_ending_here > MAX) {",
			"            MAX = max_ending_here;",
			"        }",
			"    }",
			"    if (MAX == 0) {",
			"        MAX = LLONG_MIN;",
			"        for (int i = 0; i < size; i++) {",
			"            MAX = max(MAX, A[i]);",
			"        }",
			"    }",
			"    return MAX;",
			"}",
			"",
			"template <class T>",
			"T kadane(T A[], int size, int& result_begin, int& result_end) {",
			"    T max_ending_here = 0;",
			"    T MAX = 0;",
			"    int result_begin_tmp = -1;",
			"    int result_end_tmp = -1;",
			"    for (int i = 0; i < size; i++) {",
			"        max_ending_here += A[i];",
			"        if (max_ending_here < 0) {",
			"            max_ending_here = 0;",
			"            result_begin_tmp = -1;",
			"        } else {",
			"            if (result_begin == -1) {",
			"                result_begin_tmp = i;",
			"            }",
			"            if (max_ending_here > MAX) {",
			"                MAX = max_ending_here;",
			"                result_begin = result_begin_tmp;",
			"                result_end = i;",
			"            }",
			"        }",
			"    }",
			"    if (MAX == 0) {",
			"        MAX = LLONG_MIN;",
			"        for (int i = 0; i < size; i++) {",
			"            if (MAX < A[i]) {",
			"                result_begin = i;",
			"                result_end = i;",
			"                MAX = A[i];",
			"            }",
			"        }",
			"    }",
			"    return MAX;",
			"}",
			""
		]
	}
}